# Master Client Onboarding & Codebase Guide

---

## 🤖 AI Assistant Autonomous Workflow

**🎯 MISSION:** Transform this template codebase into a fully customized website for any client through autonomous AI-driven configuration and content integration.

**📋 OVERVIEW:** This section provides the complete workflow for AI assistants to autonomously onboard new clients. The goal is 100% autonomous customization - from client input files to production-ready, deployed website - with zero human intervention required for standard customizations.

---

## 🎨 **YOUR ROLE: Multi-Disciplinary Digital Agency Expert**

**🎭 YOU ARE:** A complete digital agency condensed into one AI agent. You combine the expertise of:
- **🎨 Visual Designer:** Color theory, typography, spacing, visual hierarchy
- **💼 Brand Strategist:** Brand personality, tone of voice, market positioning
- **✍️ Copywriter:** Compelling headlines, persuasive CTAs, conversion-focused content
- **🖥️ UX/UI Designer:** User experience flows, interface design, accessibility
- **⚡ Front-end Developer:** Technical implementation, performance optimization
- **📈 Conversion Optimizer:** Landing page optimization, user psychology, A/B testing insights
- **♿ Accessibility Expert:** WCAG compliance, inclusive design, universal usability

---

## 🔧 **FULL CUSTOMIZATION SCOPE: What You Can Change**

**🚨 CRITICAL UNDERSTANDING:** This is NOT a rigid template. It's a dynamic, fully customizable system where EVERYTHING can be adjusted to fit any client perfectly.

### **🎨 Visual Customization (100% Flexible)**
- **Colors:** Every single color token can be customized via theme config
  - Primary, secondary, accent colors
  - Background gradients and patterns
  - Text colors and contrast ratios
  - Border and shadow colors
- **Typography:** Complete typographic control
  - Font families, weights, sizes
  - Line heights, letter spacing
  - Responsive scaling
- **Spacing & Layout:** Granular control over all spacing
  - Section padding and margins
  - Component spacing
  - Content density (tight/balanced/airy)
- **Visual Style:** Border radius, shadows, effects
  - Sharp/medium/soft visual personalities
  - Pattern overlays and textures
  - Animation preferences and micro-interactions

### **🏗️ Structural Customization (Complete Flexibility)**
- **Page Architecture:** Enable/disable any page or section
- **Section Order:** Completely rearrange homepage and page layouts
- **Content Blocks:** Add, remove, or modify any content section
- **Navigation:** Customize menu structure and organization
- **Feature Flags:** Toggle any functionality on/off

### **📝 Content Strategy (Adaptive Approach)**

**🎯 Content Sources (Prioritized):**
1. **Client-Provided Copy:** Direct 1:1 copy when available
2. **Client Examples:** Adapt and optimize existing content
3. **AI-Generated Content:** Create from business context and best practices
4. **Hybrid Approach:** Combine client input with professional optimization

**✍️ Your Copywriting Responsibilities:**
- **Headlines:** Craft compelling, benefit-focused headlines
- **CTAs:** Create action-oriented, conversion-focused calls-to-action
- **Value Propositions:** Articulate clear, differentiated value statements
- **Service Descriptions:** Write persuasive, benefit-driven copy
- **About Content:** Develop trust-building, personality-rich narratives
- **SEO Optimization:** Integrate keywords naturally while maintaining readability

---

## 🧠 **ADAPTIVE INTELLIGENCE: Reading Client Context**

**🔍 Information Analysis Spectrum:**

### **🎯 High-Information Clients:**
- Detailed brand guidelines provided
- Specific color palettes and fonts
- Existing copy and content examples
- Clear business positioning
- **Your Role:** Faithful implementation with professional optimization

### **🎨 Creative-Freedom Clients:**
- Minimal specific guidance
- "Make it look professional" requests
- Industry context only
- **Your Role:** Full creative control using industry best practices and design expertise

### **📊 Data-Driven Approach:**
- **Industry Research:** Understand sector-specific design trends
- **Competitor Analysis:** Research visual and content patterns in their industry
- **Conversion Psychology:** Apply user behavior insights
- **Accessibility Standards:** Ensure WCAG AA compliance always
- **Performance Optimization:** Maintain Core Web Vitals excellence

---

## 🎯 **QUALITY STANDARDS: Professional Excellence**

**🏆 Every Website Must Achieve:**

### **🎨 Visual Excellence:**
- Professional, modern design that reflects brand personality
- Consistent visual hierarchy and typography
- Optimal color contrast (WCAG AA minimum)
- Responsive design across all devices

### **⚡ Technical Performance:**
- Lighthouse scores: 90+ across all metrics
- Fast loading times (< 3s LCP)
- Smooth animations and interactions
- Cross-browser compatibility

### **💼 Business Results:**
- Clear value propositions and calls-to-action
- Optimized conversion funnels
- SEO-ready content and structure
- Lead generation optimization

### **♿ Accessibility & Inclusion:**
- Screen reader compatibility
- Keyboard navigation support
- Color-blind friendly design
- Clear content hierarchy

---

## 🎨 **DESIGN EXPERTISE: Your Creative Arsenal**

### **🌈 Color Psychology & Application:**
- **Professional Services:** Blues, grays (trust, reliability)
- **Creative Agencies:** Bold, vibrant palettes (innovation, creativity)
- **Healthcare:** Calming blues, greens (healing, trust)
- **Technology:** Modern, high-contrast (innovation, precision)
- **Finance:** Conservative, trustworthy (stability, security)

### **📐 Typography & Hierarchy:**
- **Headings:** Bold, attention-grabbing, benefit-focused
- **Body Text:** Readable, scannable, appropriate line height
- **CTAs:** Contrasting, action-oriented, prominent placement

### **🔄 User Experience Patterns:**
- **Hero Sections:** Clear value prop + primary CTA
- **Social Proof:** Testimonials, logos, case studies
- **Service Sections:** Benefit-focused, not feature-focused
- **About Sections:** Personal, trustworthy, credible
- **Contact:** Multiple touchpoints, low-friction forms

---

## 🎭 **BRAND PERSONALITY TRANSLATION**

**🎯 Transform Business Context Into Visual Identity:**

### **Professional/Corporate:**
- Clean lines, generous whitespace
- Conservative color palette
- Formal typography
- Structured layouts

### **Warm/Approachable:**
- Rounded corners, softer shadows
- Warm color tones
- Friendly typography
- Personal photography

### **Bold/Innovative:**
- Strong contrasts, dynamic layouts
- Vibrant color schemes
- Modern typography
- Cutting-edge interactions

---

## 📈 **CONVERSION OPTIMIZATION MINDSET**

**🎯 Every Design Decision Should:**
- Guide users toward primary goals
- Reduce cognitive load and friction
- Build trust and credibility
- Communicate value clearly
- Encourage action

**🔍 Psychology-Driven Elements:**
- **Scarcity:** Limited time offers, exclusive access
- **Social Proof:** Testimonials, client logos, reviews
- **Authority:** Credentials, certifications, awards
- **Reciprocity:** Free resources, valuable content
- **Clarity:** Clear benefits, simple navigation

---

**🎯 REMEMBER:** You're not just implementing a template—you're crafting a complete digital experience that represents the client's brand, serves their business goals, and delights their users. Every color choice, every word, every interaction should be intentional and strategic.

---

### 🔄 **MANDATORY 3-STEP WORKFLOW**

#### **STEP 1: Complete System Understanding & Validation** ⚡
**Objective:** Achieve deep, comprehensive understanding of the entire template system before making any changes.

**Actions Required:**
1. **Read this entire document (`docs/onboarding/master-client-onboarding.md`) from top to bottom**
   - Do not skim - understand every section, pattern, and constraint
   - Pay special attention to sections 18-21 (advanced patterns, design systems, troubleshooting)
   - Understand the 5-layer text color system, border radius system, and button hover patterns
   - Memorize the critical patterns: config-driven everything, no hardcoded values, testing discipline

2. **Study the core configuration files:**
   - `lib/site.config.local.ts` - Master configuration and theme system
   - `lib/theme.variants.ts` - Theme variant definitions
   - `lib/data/staticContent.ts` - All placeholder content
   - `app/layout.tsx` - Theme injection and global setup
   - `components/layout/DynamicPageRenderer.tsx` - Page composition system

3. **Validate current system integrity:**
   ```bash
   npm run verify:local
   ```
   - Must pass with ZERO errors before proceeding
   - If any issues exist, document them and fix before continuing

4. **Review visual references:**
   - Study all screenshots in `docs/onboarding/example-screenshots-preview/`
   - Understand the visual structure and design patterns of template pages

**⚠️ CRITICAL:** Do not proceed to Step 2 until you can confidently explain:
- How the theme system works and injects CSS variables
- How sections are composed and rendered dynamically
- How content is structured and validated
- How the testing and build pipeline functions
- Why specific patterns exist (button hover effects, text color layers, etc.)

---

#### **STEP 2: Client Analysis & Blueprint Creation** 🎨
**Objective:** Analyze all client materials and create a comprehensive customization blueprint.

**Actions Required:**
1. **Read all client input files in `docs/onboarding/client-input-files/`:**
   - Text files, requirements documents, brand guidelines
   - Existing website screenshots or references
   - Any specific instructions or preferences
   - Business context, industry, target audience information

2. **Create comprehensive client blueprint in `docs/onboarding/client-input-files/blueprint-plan-client-codebase-profile.md`:**

   **Required blueprint sections:**
   ```markdown
   # Client Codebase Profile & Implementation Blueprint
   
   ## Client Overview
   - Business name, industry, target audience
   - Brand personality and tone (professional/warm/bold)
   - Key value propositions and differentiators
   
   ## Visual & UX Strategy
   - Recommended theme variant (v1/v2/v3) and rationale
   - Color scheme adjustments needed
   - Typography and spacing preferences (balanced/tight/airy)
   - Visual style preferences (sharp/medium/soft border radius)
   
   ## Page Architecture & Content Strategy
   - Which pages to enable/disable in siteConfig.features
   - Section order and composition for each page
   - Content migration plan from placeholder to real content
   - SEO strategy and metadata approach
   
   ## Technical Implementation Plan
   - Configuration changes needed in site.config.local.ts
   - Theme customizations required
   - Asset pipeline requirements (images, logos, etc.)
   - Third-party integrations (analytics, forms, etc.)
   
   ## Quality Assurance Plan
   - Testing strategy for customizations
   - Performance benchmarks to maintain
   - Accessibility considerations
   - Browser compatibility requirements
   
   ## Deployment & Handoff Strategy
   - Staging validation checkpoints
   - Client approval workflow
   - Documentation for client
   - Maintenance and update procedures
   ```

3. **Document potential challenges and solutions:**
   - Identify any non-standard requirements
   - Plan workarounds for edge cases
   - Note any custom development needs

**⚠️ VALIDATION:** The blueprint must be comprehensive enough that any AI assistant could execute the plan without additional context.

---

#### **STEP 3: Enhanced Context & Guidelines Integration** 📚
**Objective:** Incorporate any additional instructions and guidelines that enhance the customization quality.

**Actions Required:**
1. **Read all files in `docs/onboarding/extra-instructions-guidelines/`:**
   - Tone of voice guidelines
   - Industry-specific requirements
   - Legal/compliance considerations
   - Any custom development patterns

2. **Update the blueprint with enhanced guidelines:**
   - Integrate tone of voice into content strategy
   - Apply industry-specific best practices
   - Document any special compliance requirements

3. **Prepare for execution phase:**
   - Validate all prerequisites are met
   - Ensure understanding of client requirements
   - Confirm technical feasibility of all planned changes

---

### 🚀 **EXECUTION PHASE: Autonomous Implementation**

After completing the 3-step workflow, proceed with systematic implementation:

#### **Phase A: Configuration & Theme Setup** ⚙️
1. **Update core configuration (`lib/site.config.local.ts`):**
   - Business information and branding
   - Theme variant selection and customizations
   - Feature flags and page enablement
   - Third-party service configurations

2. **Content migration:**
   - Replace placeholder content in `lib/data/staticContent.ts`
   - Update all meta-instructional copy with real content
   - Ensure content follows established patterns and best practices

3. **Asset pipeline:**
   - Add client images to `assets/images/raw/`
   - Run `npm run image-optimize`
   - Update fallback images and placeholders

#### **Phase B: Validation & Quality Assurance** ✅
1. **Mandatory testing workflow:**
   ```bash
   npm run verify:local
   ```
   - Must pass with zero errors
   - Fix any issues immediately

2. **Visual quality assurance:**
   - Test all pages in different viewport sizes
   - Validate theme consistency across all sections
   - Ensure accessibility compliance (WCAG AA)
   - Verify performance metrics (Core Web Vitals)

3. **Content quality review:**
   - Spell check and grammar review
   - SEO optimization validation
   - Call-to-action effectiveness
   - Brand consistency check

#### **Phase C: Deployment & Documentation** 🚀
1. **Staging deployment:**
   - Deploy to staging environment
   - Conduct comprehensive smoke testing
   - Document any issues and resolutions

2. **Production deployment:**
   - Push to main branch (triggers auto-deployment)
   - Monitor deployment for issues
   - Validate live site functionality

3. **Client documentation:**
   - Create client-specific documentation
   - Update maintenance procedures
   - Provide training materials if needed

---

### 🛡️ **CRITICAL SUCCESS FACTORS**

#### **Quality Gates (Never Skip These):**
- ✅ All tests pass (`npm run verify:local`)
- ✅ Zero console errors or warnings
- ✅ Lighthouse scores maintain/improve baseline
- ✅ All pages load correctly in multiple browsers
- ✅ Mobile responsiveness validated
- ✅ Accessibility compliance confirmed

#### **Common Pitfalls to Avoid:**
- 🚫 Skipping the full system understanding (Step 1)
- 🚫 Making changes without running tests first
- 🚫 Hardcoding colors or values instead of using theme system
- 🚫 Breaking existing patterns for "custom" solutions
- 🚫 Deploying without comprehensive validation

#### **Emergency Procedures:**
- **If tests fail:** Stop immediately, analyze logs, fix issues before proceeding
- **If deployment fails:** Investigate immediately, prepare rollback if needed
- **If client requirements seem impossible:** Document clearly and escalate

---

### 🔮 **ADVANCED AUTONOMOUS FEATURES**

#### **Intelligent Content Enhancement:**
- Analyze industry best practices for content optimization
- Suggest improved headlines, CTAs, and value propositions
- Optimize content for SEO while maintaining readability
- Ensure content matches brand personality and tone

#### **Performance Optimization:**
- Automatically optimize images and assets
- Minimize bundle sizes through intelligent imports
- Implement performance best practices
- Monitor and report Core Web Vitals improvements

#### **Accessibility Enhancement:**
- Validate color contrast ratios automatically
- Ensure keyboard navigation works perfectly
- Optimize for screen readers
- Test with various accessibility tools

#### **Future-Proofing:**
- Document all customizations made
- Create upgrade paths for future enhancements
- Maintain compatibility with theme system updates
- Provide maintenance recommendations

---

### 📊 **SUCCESS METRICS & REPORTING**

After successful completion, provide a comprehensive report including:

1. **Implementation Summary:**
   - Changes made to configuration
   - Content updates completed
   - Theme customizations applied
   - Features enabled/disabled

2. **Quality Metrics:**
   - Test results (all must be passing)
   - Performance metrics (before/after)
   - Accessibility compliance status
   - Cross-browser compatibility results

3. **Client Deliverables:**
   - Live website URL
   - Staging environment access
   - Admin documentation
   - Maintenance procedures

4. **Recommendations:**
   - Future enhancement opportunities
   - Ongoing maintenance tasks
   - Performance monitoring suggestions
   - Content update recommendations

---

**🎯 REMEMBER:** This system is designed for 100% autonomous operation. Every decision should be data-driven, every change should be tested, and every customization should follow established patterns. The goal is to deliver production-ready websites that exceed client expectations while maintaining the highest quality standards.

---

## 🚀 Quickstart & AI Recipes

**For AI Assistants and Human Developers:**
- **Zero-context onboarding:**
  1. Read this doc, `lib/site.config.local.ts`, `lib/theme.variants.ts`, and `lib/data/staticContent.ts`.
  2. To scaffold a new client: update config, inject copy, run `npm run verify:local`.
  3. Use codemods/scripts for placeholder extraction, color migration, and fallback image replacement.
  4. Always validate changes by running the full verification workflow and manual visual QA on key pages.
- **AI Automation Recipes:**
  - To add a new section: update `siteConfig.pageStructures`, extend the section schema in `lib/schemas/sections.schema.ts`, and add/override data in `lib/data/`.
  - To add a new theme variant: extend `lib/theme.variants.ts`, update `app/layout.tsx` logic, and document in this doc and config.
  - To migrate hardcoded colors: use codemods and lint rules, then update tokens in `theme/colors.ts` and config.
  - To update placeholder copy: extract from `lib/data/staticContent.ts`, replace, and verify with tests and visual QA.

---

## Table of Contents
1. [Project Overview](#project-overview)
2. [Codebase Structure](#codebase-structure)
3. [Onboarding & Setup Workflow](#onboarding--setup-workflow)
4. [Configuration: site.config.local.ts](#configuration-siteconfiglocalts)
5. [Theming & Branding](#theming--branding)
6. [Pages, Routing & Feature Flags](#pages-routing--feature-flags)
7. [Section Components & Data-Driven Content](#section-components--data-driven-content)
8. [Images & Asset Pipeline](#images--asset-pipeline)
9. [SEO, Metadata & Performance](#seo-metadata--performance)
10. [Cookie Consent & Tracking](#cookie-consent--tracking)
11. [Testing, Linting & Quality Gates](#testing-linting--quality-gates)
12. [Build, Deployment & CI](#build-deployment--ci)
13. [Newsletter & Contact Form Providers](#newsletter--contact-form-providers)
14. [Dynamic Theming & Advanced Configuration](#dynamic-theming--advanced-configuration)
15. [Troubleshooting, Gotchas & Post-Mortems](#troubleshooting-gotchas--post-mortems)
16. [AI/Automation Best Practices](#aiautomation-best-practices)
17. [Appendix: Feature Flags, Patterns, and Utilities](#appendix-feature-flags-patterns-and-utilities)
18. [Advanced Patterns & Utilities](#advanced-patterns--utilities)
19. [Design System & Visual Patterns](#design-system--visual-patterns)
20. [How to Update This Doc](#how-to-update-this-doc)
21. [Lessons from Past Phases & Common Pitfalls (Appendix)](#lessons-from-past-phases--common-pitfalls-appendix)

---

## 1. Project Overview

The GMG Template Website 2025 is a highly configurable, modern, and robust Next.js template designed for service professionals. It features a single source of truth for all theming, content, and configuration, and is built for rapid onboarding, customization, and future-proof handover to both AI and human developers.

---

## 2. Codebase Structure

- **app/**: All Next.js app routes, including homepage, about, services, blog, resources, landing pages, etc.
- **components/**: UI, layout, content blocks, sections, analytics, SEO, tracking, etc.
- **lib/**: Data sources, schemas, config, and utility functions.
- **public/**: Static assets (images, textures, etc.).
- **tests/**: Unit, integration, and E2E tests (Vitest, Playwright).
- **theme/**: Tailwind and global style configuration.
- **docs/**: All documentation, onboarding, and design blueprints.

---

## 3. Onboarding & Setup Workflow

- Clone the repo and install dependencies (`npm install`).
- All configuration is centralized in `lib/site.config.local.ts` (theme, features, content structure).
- Run the all-in-one verification script before pushing changes:
  ```bash
  npm run verify:local
  ```
- All theming, content, and feature flags are validated by Zod schemas in `lib/site.config.ts`.
- Never assume onboarding docs are up-to-date—always validate against the codebase.

---

## 4. Configuration: site.config.local.ts

- The homepage and all major sections use meta-instructional placeholder copy, guiding content creators to use best practices for headlines, CTAs, social proof, value props, features, pain/solution, testimonials, services, about, blog, pricing, FAQ, and CTA.
- Each section's content is structured for clarity, SEO, and conversion, with explicit instructions for alt text, accessibility, and dynamic content placeholders.
- The homepage serves as the design and content benchmark for all other pages.
- See `docs/building/designing/phase2-homepage-copy.md` for detailed meta-instructional copy patterns.

---

## 5. Theming & Branding

- **Single source of truth**: All colors, typography, spacing, borders, and shadows are defined in `lib/site.config.local.ts` under `theme`.
- **Variants**: Multiple theme variants are defined in `lib/theme.variants.ts`. The active variant is set in `app/layout.tsx` via a `themeKey` or ENV variable (`THEME_VARIANT`).
- **SSR CSS variable injection**: All theme tokens are injected at SSR in `<head>`, with no runtime JS. This prevents FOUC and ensures instant theme application.
- **Tailwind mapping**: All theme tokens are mapped to Tailwind utilities using slash-syntax (e.g., `bg-primary/20`). No hardcoded colors or dash-syntax.
- **No hardcoded colors**: All color usage is via tokens; codemods and ESLint enforce this.
- **Testing**: Unit and E2E tests verify CSS variable and utility resolution.
- **Documentation**: All new config options and tokens are documented in `site.config.local.ts` and onboarding docs.
- **Accessibility**: All color combos must meet WCAG AA contrast, and all animations must respect `prefers-reduced-motion`.

---

## 6. Pages, Routing & Feature Flags

- **Test structure:** All tests live under `tests/` with subfolders for `unit/` (Vitest), `integration/` (Vitest + MSW), and `e2e/` (Playwright).
- **E2E:** Playwright config and scripts for all major flows (homepage, about, contact, dynamic routes).
- **Unit:** Vitest for UI components, feature flags, utility functions, and API schema validation.
- **Integration:** Vitest + MSW for API endpoints and middleware.
- **Accessibility:** Use `jest-axe` for a11y checks in Vitest.
- **Lighthouse:** Optional CI integration for performance and a11y regression.
- **CI:** `npm test` runs all suites; scripts are in `package.json`.
- **Naming and placement conventions** are strictly followed for easy discoverability.

---

## 7. Section Components & Data-Driven Content

- **Section architecture**: All pages are composed of reusable, configurable section components (e.g., HeroSection, AboutSection, ServicesSection, etc.) found in `components/sections/`.
- **Section data**: Content for each section/page is driven by data modules in `lib/data/` and validated by Zod schemas.
- **Dynamic page structures**: Page layouts and section order are defined in `siteConfig.pageStructures` (see `lib/site.config.local.ts`).
- **Section wrappers**: All hero/top sections use the `Section` component with `bgClass` from config (e.g., `siteConfig.sectionStyles.heroGradient`).
- **No local overrides**: Typography, spacing, and backgrounds are controlled by global config and utility classes.
- **Animations**: Scroll-triggered and staggered animations are handled by `<LazySection>` and controlled by feature flags in `siteConfig.features`.
- **Testing**: All section components are covered by unit and E2E tests.

## 7. Section Architecture & Dynamic Page Composition

- **Section-driven pages:** All pages are composed of reusable, configurable section components (e.g., HeroSection, AboutSection, ServicesSection, etc.), with layouts and order defined in `siteConfig.pageStructures`.
- **DynamicPageRenderer:** Central to rendering pages from config, enabling no-code reordering and extension of sections. See `components/layout/DynamicPageRenderer.tsx`.
- **Per-section visual overrides:** Each section can have its own background pattern, opacity, and color, set via config and validated by Zod schemas. Extend each section's data schema and pass overrides as props (see `lib/schemas/sections.schema.ts`).
- **No manual padding/containers:** Section spacing and container classes are config-driven for consistency and simplicity.
- **Pattern system:** Patterns (dots, grid, waves, etc.) are defined in config and can be overridden per section. See `theme-templating-variants.md` and `lib/site.config.local.ts`.
- **Testing:** All section components are covered by unit and E2E tests. Always run `npm run verify:local` after changes.

---

## 8. Images & Asset Pipeline

- **Raw images**: Source images are stored in `assets/images/raw/`.
- **Optimized images**: Use `npm run image-optimize` to generate optimized images in `public/images/` and `blurDataURL.json`.
- **Image components**: Use `next/image` or `<OptimizedImage />` for all images; no `<img>` tags.
- **Fallbacks**: All fallback images use `DEFAULT_PLACEHOLDER_IMAGE` from `lib/constants.ts`.
- **Testing**: E2E and unit tests verify image loading and fallbacks.

---

## 9. SEO, Metadata & Performance

- **SEO**: All metadata is driven by config and per-page overrides using Next.js App Router's `generateMetadata`.
- **JSON-LD**: Organization, WebSite, BreadcrumbList, Article, and FAQ schemas are emitted dynamically based on content.
- **Sitemap & robots.txt**: Generated via `next-sitemap`, filtering routes based on feature flags and `enabledPages` in config.
- **Lighthouse**: Lighthouse testing is done on real Vercel deployments using `npm run lhci:prod` for accurate results. Local CI testing has been removed due to environment reliability issues.
- **Performance**: Hero images use `next/image` with `priority`, explicit width/height, and are preloaded. Unused JS/CSS is purged, and heavy scripts are dynamically imported. DOM size is minimized by removing excessive wrappers and using semantic lists.
- **Validation**: After each change, run build, lint, test, E2E, and Lighthouse on the deployed site. All enhancements must maintain or improve Core Web Vitals.

---

## 10. Cookie Consent & Tracking

- **Consent gating**: Tracking scripts (GTM, GA4, Facebook Pixel, LinkedIn, HubSpot, Google Ads) are only injected if the user has given the appropriate consent **and** the corresponding tracking ID is set in `siteConfig.tracking`.
- **No empty scripts**: Prevents broken or unnecessary script loads; improves performance and onboarding safety.
- **Dev warnings**: Optionally log a warning in development if consent is given but an ID is missing.
- **Pattern**: See `components/tracking/tracking-scripts.tsx` for the implementation.
- **Documentation**: This pattern is documented in onboarding docs for future maintainers.

---

## 11. Testing, Linting & Quality Gates

- **Strict import sorting**: Enforced via `simple-import-sort/imports` and `simple-import-sort/exports` in `.eslintrc.json`.
- **No hardcoded colors**: Custom ESLint/regexp rules ban hex literals and raw Tailwind color classes. All color usage must be via semantic tokens defined in the theme config.
- **No `<img>` tags**: Use `next/image` or `<OptimizedImage />` for all images.
- **Accessibility**: Enforced via `jsx-a11y` rules for alt text, focus, and anchor validity.
- **No console/debugger**: Only `console.error` via a shared logger is allowed.
- **Layer boundaries**: `boundaries/no-cross-imports` prevents cross-layer imports (e.g., `components/` cannot import from `app/`).
- **CI enforcement**: Lint, Biome, and all tests must pass before merge. Run `npm run lint -- --fix`, `npx biome lint app components lib hooks`, and `npm test`.
- **Automated dependency management**: Dependabot or similar tools are used for regular updates, with CI checks on every PR.

## 12. Build, Deployment & CI

- **Next.js 15+ SWC JSX runtime**: No default `React` import; all direct API calls (`forwardRef`, hooks, context) must use named imports.
- **Biome's `useImportType`**: Strips type-only React imports; always use `import type` for types.
- **"use client"**: Must be the first line in any client component.
- **Automated codemod**: Used to migrate all components to named imports and correct `"use client"` placement.
- **Build & CI**: Always run `npm run build`, `npm run lint -- --fix`, and `npm test` before deployment.
- **Staging validation**: Deploy to staging and smoke-test before merging to `main`.
- **Full verification**: Use `npm run verify:local` to clear production cache, build, lint, type-check, run all tests, and E2E in one command.
- **Production builds**: Output to `.next-prod` to avoid interfering with dev builds.
- **Push to `main` only after all checks pass**: This triggers Vercel auto-deployment.

---

## 13. Newsletter & Contact Form Providers

- **Config-driven**: Newsletter and contact form providers are configured in `siteConfig.newsletter` and `siteConfig.contactForm`.
- **Supported providers**: Mailchimp, HubSpot, ActiveCampaign, SMTP, SendGrid, Postmark (see config for details).
- **Dynamic fields**: Contact form fields are generated from config and validated by Zod schemas.
- **Spam protection**: Honeypot and reCAPTCHA are supported and configurable.
- **Testing**: All provider modes and validation logic are covered by unit and integration tests.

---

## 14. Dynamic Theming & Advanced Configuration

- **Theme variants**: All theme variants are defined in `lib/theme.variants.ts`. The active variant is set in `app/layout.tsx` via a `themeKey` or ENV variable (`THEME_VARIANT`).
- **SSR CSS variable injection**: At build/SSR, only the active variant's tokens are injected into `<head>`, ensuring no FOUC and minimal CSS.
- **Section-level overrides**: `siteConfig.sectionOverrides` can be used to preview different variants per section (see `theme-templating-variants.md`).
- **Opacity syntax**: All color utilities use Tailwind's slash-syntax (e.g., `bg-primary/10`). Dash-syntax is deprecated and enforced via codemod and lint rules.
- **Testing**: Visual QA, unit, and E2E tests verify correct theme application and color contrast.
- **Performance**: Only the active variant's CSS variables are shipped; unused classes are purged by Tailwind.
- **Previewing**: Use `?theme=v2` in the URL or set `THEME_VARIANT` in `.env.local` to preview different variants.

## 15. Troubleshooting, Gotchas & Post-Mortems

- **React API imports**: All direct React API calls (e.g., `forwardRef`, hooks, context) must use named imports; no default or namespace imports.
- **"use client"**: Must be the first line in any client component.
- **Biome/ESLint**: Strictly enforce import types, color usage, and import sorting.
- **Tailwind JIT**: Any class name computed at runtime must appear as a literal string in the source or be safelisted in `tailwind.config.ts`.
- **Pattern defaults**: Section backgrounds/patterns are off by default; must be explicitly enabled in config.
- **No hardcoded brand colors**: Always use theme tokens or CSS variables; codemods and lint rules enforce this.
- **Framer Motion**: Always use numeric cubic-bezier arrays for easing, not CSS variable strings.
- **Dynamic section spacing**: Section vertical padding is config-driven via `siteConfig.theme.visualStyle.contentDensity` and mapped to literal classes for Tailwind JIT compatibility.
- **Lighthouse/Performance**: Always run Lighthouse and a11y checks before merging; document results in `docs/lighthouse-gains.md`.
- **CI/Build**: All enhancements are verified with ESLint, production build, unit/integration/E2E tests, and manual staging review before merging.
- **Color audit**: See `misconfigs-final.txt` for any remaining hardcoded color usages to be migrated.

## 16. AI/Automation Best Practices

- **Zero-context onboarding**: All placeholder content and fallback images are centralized for easy AI-driven customization.
- **Codemods/scripts**: Use codemods and regex scripts to extract/replace placeholders, color literals, and fallback images.
- **CI enforcement**: Lint rules and tests block regressions; run `npm run ci:verify` after any automated change.
- **Automated dependency management**: Dependabot or similar tools keep dependencies up to date, with CI checks on every PR.
- **Documentation**: All onboarding, customization, and build steps are documented for AI and human maintainers.
- **Visual QA**: Automated and manual visual checks are required after any major change or codemod.
- **Zero-context chat prompt**: For new client builds, load `staticContent.ts`, `constants.ts`, `theme/colors.ts`, `site.config.local.ts`, and the unified build blueprint; inject client copy, update branding, and run `npm run ci:verify`.

## 17. Appendix: Feature Flags, Patterns, and Utilities

- **Feature flags**: All major features and sections are toggled via `siteConfig.features` (see `lib/site.config.local.ts`).
- **Pattern system**: Section backgrounds can opt into patterns/textures via config; patterns are off by default and must be explicitly enabled.
- **Section styles**: Centralized in `siteConfig.sectionStyles` for gradients, banners, and other shared styles.
- **Semantic tokens**: All color, spacing, and typography tokens are semantic and reflect UI role, not color value.
- **Testing utilities**: Unit, integration, and E2E tests cover all major flows, including theming, section rendering, and tracking.
- **Color audit**: `misconfigs-final.txt` lists all hardcoded color usages to be migrated to tokens.
- **References**: See `docs/building/general/`, `lib/site.config.local.ts`, `lib/theme.variants.ts`, `theme/colors.ts`, and onboarding docs for further details.

## 18. Advanced Patterns & Utilities

### Web Vitals API & Analytics Utilities
- **Custom endpoint:** `app/api/web-vitals/route.ts` collects web vitals metrics for analytics/performance monitoring. Metrics can be forwarded to any analytics service. See also `components/analytics/WebVitalsReporter.tsx` for client-side reporting.
- **Pattern:** Use this endpoint to collect and analyze real user performance data. Extend as needed for custom analytics.

### Dynamic Page Composition: DynamicPageRenderer
- **Component:** `components/layout/DynamicPageRenderer.tsx` enables config-driven, highly dynamic page layouts. Page structures are defined in `siteConfig.pageStructures` and mapped to section components at runtime.
- **Pattern:** To add or reorder sections, update the config—no code changes needed. Extend this renderer for new section types or custom logic.

### Content Block System
- **Directory:** `components/content-blocks/` contains modular blocks (FormBlock, CtaBlock, HeadingBlock, HeadingBlock, QuoteBlock, TextBlock, VideoBlock, ImageBlock, ListBlock, ContentBlockRenderer, etc.).
- **Pattern:** Use for rich, flexible, CMS-like content editing. Compose complex content from reusable blocks. Extend with new block types as needed.

### Custom UI Primitives
- **Directory:** `components/ui/` contains a large set of custom UI primitives (button, card, input, carousel, background-pattern, spark-button, lazy-section, optimized-image, etc.).
- **Pattern:** Use these for consistent UI/UX. Many are not just wrappers for shadcn/ui, but have custom logic (e.g., BackgroundCanvas for animated backgrounds, lazy-section for scroll-triggered animations, optimized-image for image optimization).
- **Equal height cards:** All card components (TestimonialCard, ServiceCard, etc.) support equal height layouts using CSS Grid and flexbox. Use `card-equal-height justify-items-center` on the grid container, wrap each card in a `size-full max-w-sm` div, and use `size-full flex flex-col justify-between` on the Card component. See working examples in `blog-section.tsx` and `services/page.tsx`. The global CSS includes `.card-equal-height` utilities for consistent card behavior.

#### ⚠️ CRITICAL: Button Hover Effects in Card-Based Designs

**The Pattern:** Buttons inside cards (service cards, contact forms, philosophy cards, etc.) should have **minimal or no hover effects** to maintain visual hierarchy and prevent competing animations.

**Implementation Method:**
1. **Use `animation="none"` prop** on the Button component to disable built-in hover animations
2. **Add CSS override classes** to neutralize any remaining hover effects:
   - `hover:scale-100` - Prevents scaling
   - `hover:shadow-none` - Removes shadow changes  
   - `hover:-translate-y-0` - Prevents upward movement

**Example implementations:**
```tsx
// ✅ CORRECT - Philosophy card button (about-section.tsx)
<Button animation="none" className="mt-4">
  Learn More
</Button>

// ✅ CORRECT - Service card buttons (service-card.tsx)  
<Button animation="none" className="hover:scale-100 hover:shadow-none">
  Discover More
</Button>

// ✅ CORRECT - Contact form button (contact-section.tsx)
<Button 
  type="submit"
  animation="none" 
  className="w-full hover:scale-100 hover:shadow-none hover:-translate-y-0"
  disabled={isSubmitting}
>
  Send message
</Button>
```

**Why This Matters:**
- **Visual hierarchy**: Cards are the primary interactive element; buttons inside should be secondary
- **Design consistency**: Prevents competing animations that create visual chaos
- **Professional appearance**: Maintains the calm, sophisticated design language
- **User experience**: Avoids distracting micro-interactions within already interactive containers

**Common Mistake:** Only adding CSS override classes without the `animation="none"` prop. The Button component has built-in hover effects that must be disabled at the component level.

**Debugging:** If you see buttons still moving/scaling on hover, check that both the `animation="none"` prop AND the CSS override classes are applied.

- **Best practice:** Prefer these primitives over raw HTML or third-party components for consistency and maintainability.

### Utility Modules
- **Files:** `lib/data-utils.ts`, `lib/tracking-utils.ts`, `lib/icon-utils.tsx`, `lib/animation.ts`, `lib/utils.ts`.
- **Pattern:** Centralize data transformation, tracking, icon, and animation logic. Review and extend these utilities as needed for new features.

### Layout & Navigation Patterns
- **Directory:** `components/layout/` contains AppShell, Section, PageTransitionWrapper, header, footer, navigation, etc.
- **Pattern:** Use AppShell for global layout, Section for section wrappers, PageTransitionWrapper for animated transitions, and navigation/header/footer for site-wide navigation. Sticky headers, dynamic navigation, and page transitions are all handled here.
- **Navigation hover functionality:** The header navigation automatically opens dropdown menus on hover for `/services` and `/resources` navigation items. This provides a smooth, modern UX without requiring clicks. The dropdowns auto-close when the mouse leaves both the trigger and the dropdown content.
- **Mobile navigation:** Uses portal-based overlay to escape stacking context issues. Includes expandable submenus for services and resources with smooth animations.
- **Best practice:** Extend these primitives for new layout or navigation needs, and keep navigation config-driven via `siteConfig`.

### SEO & Structured Data Utilities
- **Directory:** `components/seo/` contains structured-data.tsx and blog-schema.tsx for rich JSON-LD schema generation.
- **Pattern:** Use and extend these utilities for advanced SEO needs, including custom schema types for new content.

### Analytics & Tracking
- **Directory:** `components/tracking/` contains DataLayerProvider, tracking-scripts.tsx, and PageViewTracker for analytics and consent gating.
- **Pattern:** All tracking scripts are consent-gated and config-driven. Extend these for new analytics providers or custom tracking needs.

### Content & Placeholder Extraction
- **Pattern:** All placeholder copy is centralized in `lib/data/staticContent.ts`. Use codemods/scripts to extract or replace placeholders and fallback images. CI and lint rules enforce no new inline placeholders.

### Section Dividers & WordPress-Style Wave Styling
- **Component:** `components/ui/section-divider.tsx` provides rich, WordPress-style section dividers with advanced wave and border styling options.
- **Available variants:** 
  - `wave` - Classic smooth wave pattern
  - `curve` - Simple curved divider
  - `triangle` - Geometric triangle points
  - `zigzag` - Sharp zigzag pattern
  - `clouds` - Organic cloud-like shapes
  - `mountains` - Mountain peak silhouettes
  - `flowing-wave` - More organic flowing wave
  - `double-wave` - Two-layer wave effect
- **Configuration options:**
  - `position`: 'top' | 'bottom' - Where to place the divider
  - `size`: 'sm' | 'md' | 'lg' | 'xl' - Height of the divider
  - `fill`: CSS class for fill color (e.g., 'fill-white', 'fill-primary')
  - `flip`: boolean - Flips the pattern vertically
- **Usage pattern:** Place between sections to create visual separation and add professional polish. Perfect for breaking up content sections, especially when sections have different background colors.
- **Example:**
  ```tsx
  <SectionDivider 
    variant="flowing-wave" 
    position="bottom" 
    size="lg" 
    fill="fill-white" 
  />
  ```
- **Best practice:** Use dividers sparingly for maximum impact. Match the `fill` color to the section above (for bottom dividers) or below (for top dividers) to create seamless transitions.

## 19. Design System & Visual Patterns

- **Configurable everything:** All visual options (patterns, gradients, spacing, typography, animations) are centrally configurable in `siteConfig` and theme variants.
- **Typography & spacing:** Global, responsive typography scale and spacing system, with "balanced", "tight", and "airy" options. See `theme/` and `app/globals.css`.
- **Pattern library:** Configurable background patterns (dots, grid, waves, etc.) and gradients, with per-section overrides.
- **Component variants:** Buttons, cards, and other primitives have variant-specific personalities (Professional, Warm, Bold). See `components/ui/`.
- **CSS modules:** Used only for complex, scoped animations (e.g., infinite logo carousels).
- **Performance & accessibility:** All enhancements must maintain or improve Core Web Vitals and meet WCAG AA contrast. Animations must respect `prefers-reduced-motion`.
- **Consistent variant ecosystem:** All design decisions must work across all theme variants (v1, v2, v3).
- **Micro-interactions:** Subtle, purposeful, and always optional/configurable. See `components/ui/lazy-section.tsx` and `components/layout/PageTransitionWrapper.tsx`.

## 19.1 Centralized Border Radius Theme System

**⚠️ CRITICAL:** This system centralizes all border radius styling through theme configuration. Always use the theme system instead of hardcoded Tailwind classes like `rounded-lg`.

### System Overview
The border radius system provides consistent, theme-driven styling across all components through:
- **Global adjustment**: Choose 'sharp', 'medium', or 'soft' visual style
- **Element-specific mappings**: Different component types get appropriate border radius scales  
- **Centralized configuration**: All values defined in `lib/site.config.local.ts`
- **CSS variable injection**: Border radius scales become CSS variables in `app/layout.tsx`

### Configuration Structure

**1. Border Radius Scales** (`siteConfig.theme.borders.radiusScales`):
```typescript
radiusScales: {
  xs: '0.125rem',   // 2px - Very small elements
  sm: '0.25rem',    // 4px - Small elements  
  md: '0.375rem',   // 6px - Default elements
  lg: '0.5rem',     // 8px - Cards, inputs
  xl: '0.75rem',    // 12px - Large sections
  '2xl': '1rem',    // 16px - Very large elements
  '3xl': '1.5rem',  // 24px - Hero sections  
  full: '9999px',   // Fully rounded (pills, avatars)
  none: '0px'       // No rounding
}
```

**2. Element Mappings** (`siteConfig.theme.visualStyle.borderRadiusMappings`):
```typescript
borderRadiusMappings: {
  // Small UI elements
  badge: 'full',     // Pills/badges are fully rounded
  pill: 'full',      // Always fully rounded
  indicator: 'full', // Status indicators
  
  // Form elements  
  button: 'md',      // Standard button rounding
  input: 'md',       // Form inputs
  
  // Content containers
  card: 'lg',        // Cards and containers
  modal: 'xl',       // Modals and dialogs
  section: 'xl',     // Page sections
  
  // Media elements
  image: 'lg',       // Images and media
  avatar: 'full',    // Profile pictures
  
  // Navigation elements
  nav: 'md',         // Navigation items
  dropdown: 'md'     // Dropdown menus
}
```

**3. Global Visual Style** (`siteConfig.theme.visualStyle.borderRadius`):
- `'sharp'`: Reduces border radius by one scale step
- `'medium'`: Uses base scale as-is  
- `'soft'`: Increases border radius by one scale step

### Component Implementation

**Client Components** use the `useThemeBorderRadius` hook:
```typescript
import { useThemeBorderRadius } from '@/hooks/use-theme-border-radius';

function MyComponent() {
  const { getBorderRadiusClass } = useThemeBorderRadius();
  
  return (
    <div className={`${getBorderRadiusClass('card')} border p-4`}>
      Content
    </div>
  );
}
```

**Server Components** use CSS variables directly:
```typescript
// In server components, use CSS variables
<div className="rounded-[var(--radius-lg)] border p-4">
  Content  
</div>
```

### CSS Variables Generated
The system automatically injects these CSS variables:
- `--radius-xs` through `--radius-3xl`
- `--radius-full` and `--radius-none`

### Migration Guidelines

**❌ NEVER use hardcoded classes:**
```typescript
// BAD - hardcoded border radius
<div className="rounded-lg border">

// BAD - inconsistent across theme variants  
<Badge className="rounded-full">
```

**✅ ALWAYS use theme system:**
```typescript
// GOOD - uses theme system (client component)
const { getBorderRadiusClass } = useThemeBorderRadius();
<div className={`${getBorderRadiusClass('card')} border`}>

// GOOD - uses CSS variable (server component)  
<div className="rounded-[var(--radius-lg)] border">

// GOOD - Badge component uses theme automatically
<Badge variant="accent">
```

### Component Coverage
The following components are already migrated to use the theme system:
- ✅ `Badge`, `Button`, `Card`, `Input`, `Textarea`, `Skeleton`
- ✅ `ServiceCard`, `TestimonialCard`, `ThemedImage`, `ThemedSection`
- ✅ Process sections, hero stats, FAQ accordion
- ✅ Cookie consent banner and various page sections

### Customization Examples

**For pill-shaped badges:**
```typescript
// In site.config.local.ts
borderRadiusMappings: {
  badge: 'full'  // Makes all badges fully rounded
}
```

**For sharp, minimal design:**
```typescript
// In site.config.local.ts  
visualStyle: {
  borderRadius: 'sharp'  // Reduces all border radius by one step
}
```

**For soft, friendly design:**
```typescript
// In site.config.local.ts
visualStyle: {
  borderRadius: 'soft'   // Increases all border radius by one step
}
```

### Debugging & Common Issues

1. **"getElementBorderRadius is not a function"**
   - You're using the hook in a server component
   - Use CSS variables instead: `rounded-[var(--radius-lg)]`

2. **Border radius not updating**
   - Check the element mapping exists in `borderRadiusMappings`
   - Verify the component is using the theme system

3. **Inconsistent styling across pages**
   - Some components still use hardcoded classes
   - Run: `grep -r "rounded-[^[]" components/` to find hardcoded usage

### Testing & Verification
After making changes to the border radius system:
1. Run `npm run build` to ensure no build errors
2. Test all theme variants (v1, v2, v3) for consistency
3. Verify visual consistency across different component types
4. Check that global adjustments (sharp/medium/soft) work properly

### ⚠️ CRITICAL: Multi-Layer Text Color Debugging in 5D Codebase

**The Challenge:** Text color issues in this codebase often span multiple files and layers, creating complex debugging scenarios that require systematic analysis.

#### Understanding the 5 Layers of Text Styling

**Layer 1: Data Content** (`lib/data/`)
- Contains the actual text content that users see
- Example: `description: 'Empathy-driven intro highlighting common client problems'`

**Layer 2: Component Rendering** (`components/sections/`)
- How the text is rendered in JSX with CSS classes
- Example: `<p className="text-section-lead max-w-[600px] text-neutral-text-subtle">`

**Layer 3: Utility Class Definitions** (`app/globals.css`)
- Where utility classes like `text-section-lead` are defined
- Example: `.text-section-lead { @apply text-lg text-foreground leading-relaxed md:text-xl; }`

**Layer 4: Color Token Mapping** (`tailwind.config.ts`)
- How color tokens resolve to actual color values
- Example: `'neutral-text-subtle': ({ opacityValue = 1 }) => hsl(210 16% 93% / ${opacityValue})`

**Layer 5: Theme Context** (`layout.tsx` + component backgrounds)
- Whether the background is light or dark affects which colors should be used
- Example: `bg-brand-secondary-dark` requires light text, `bg-white` requires dark text

#### Common Multi-Layer Conflicts

**❌ Conflicting Utility Classes:**
```tsx
// PROBLEMATIC - utilities with conflicting color definitions
<p className="text-section-lead text-neutral-text-subtle">
```
- `text-section-lead` contains `text-foreground` (dark color)
- `text-neutral-text-subtle` provides light color
- CSS specificity determines which wins (often the wrong one)

**❌ Background-Text Mismatch:**
```tsx
// PROBLEMATIC - light text utility on light background
<div className="bg-white">
  <p className="text-neutral-text-subtle">Hard to read</p>
</div>
```

#### Systematic Debugging Approach

**1. Identify the Content Layer**
```bash
# Find where the problematic text is defined
grep -r "problematic text content" lib/data/
```

**2. Locate the Component Layer**
```bash
# Find which component renders this content
grep -r "variableName\|sectionName" components/
```

**3. Analyze the Styling Classes**
- Look for multiple color-related classes on the same element
- Check if utility classes have built-in color definitions

**4. Trace Utility Class Definitions**
```bash
# Check what each utility class actually does
grep -r "text-section-lead" app/globals.css
```

**5. Verify Color Token Resolution**
```bash
# Check color token definitions
grep -r "neutral-text-subtle" tailwind.config.ts
```

**6. Assess Background Context**
- Dark backgrounds (`bg-brand-secondary-dark`, `bg-gray-900`) need light text
- Light backgrounds (`bg-white`, `bg-gray-100`) need dark text

#### Proven Fix Patterns

**✅ Remove Conflicting Utilities:**
```tsx
// BEFORE (conflicting)
<p className="text-section-lead max-w-[600px] text-neutral-text-subtle">

// AFTER (direct styling)
<p className="text-lg leading-relaxed md:text-xl max-w-[600px] text-white/90">
```

**✅ Context-Aware Color Selection:**
```tsx
// Dark background sections
<div className="bg-brand-secondary-dark">
  <p className="text-white/90">Light text for dark background</p>
</div>

// Light background sections  
<div className="bg-white">
  <p className="text-neutral-text">Dark text for light background</p>
</div>
```

**✅ Consistent Card Text Patterns:**
```tsx
// Cards on dark backgrounds
<div className="bg-white/10"> {/* Semi-transparent on dark */}
  <p className="text-white/80">Readable card text</p>
</div>

// Cards on light backgrounds
<div className="bg-gray-50"> {/* Light card */}
  <p className="text-neutral-text">Readable card text</p>  
</div>
```

#### Prevention Strategies

**1. Never Mix Color Utilities**
- Only use one color-related class per element
- If you need sizing + color, apply them separately:
  ```tsx
  // GOOD
  <p className="text-lg leading-relaxed md:text-xl text-white/90">
  
  // BAD  
  <p className="text-section-lead text-neutral-text-subtle">
  ```

**2. Create Background-Specific Utility Classes**
- Consider creating utilities like `text-dark-bg` and `text-light-bg`
- Document which utilities are safe to combine

**3. Component-Level Color Validation**
- Always test components on both light and dark backgrounds
- Use browser dev tools to verify actual computed colors

**4. Systematic Color Audit**
```bash
# Find potential conflicts
grep -r "text-.*text-" components/
grep -r "text-section-lead.*text-" components/
```

#### File Interaction Map for Text Color Issues

```
Data (lib/data/) 
    ↓ (content)
Component (components/sections/)
    ↓ (CSS classes)  
Utility Definitions (app/globals.css)
    ↓ (color tokens)
Color Configuration (tailwind.config.ts)
    ↓ (theme context)
Background Context (component styling)
```

**Remember:** Always trace the complete path from content → component → utilities → tokens → context when debugging text color issues.

## 20. How to Update This Doc

- **Validation:** All changes must be validated against the current codebase and config.
- **Checklist:**
  - Update for every new feature, pattern, or config option
  - Cross-link to new/updated blueprints or deep-dives
  - Mark any deprecated or superseded instructions
  - Review for clarity, discoverability, and accuracy
- **Process:**
  1. Review new/changed code, config, or patterns
  2. Update this doc with clear, actionable instructions
  3. Add cross-links to relevant files, blueprints, or onboarding docs
  4. Validate by running `npm run verify:local` and manual visual QA
  5. Commit and push only after all checks pass

---

This document is continuously updated as the codebase evolves. Always validate any onboarding or instructional doc against the current codebase and config files before acting.

## 21. Lessons from Past Phases & Common Pitfalls (Appendix)

### Key Lessons & Prevention Strategies

- **Always Validate Before Changing:**
  - Never assume a feature or pattern needs improvement—examine the current codebase and implementation first.
  - Use existing systems and extend them; do not create new systems unless absolutely necessary.

- **Config-Driven Everything:**
  - All visual and functional options (patterns, spacing, colors, animations) must be centrally configurable in `siteConfig` and theme variants.
  - Never hardcode brand colors or add new CSS variables/classes that aren't actually used by components.

- **Tailwind JIT & Dynamic Classes:**
  - Any class name computed at runtime must appear as a literal string in the source or be safelisted in `tailwind.config.ts`.
  - After changing config-driven classes, always rebuild and verify in the browser.

- **Section & Container Patterns:**
  - Never add container classes inside Section components—Section already provides the container.
  - For per-section pattern overrides, always extend the section's data schema and pass overrides via config, not hardcoded props.

- **Testing & Verification Discipline:**
  - Always run `npm run verify:local` after any significant change (build, lint, test, E2E, visual QA).
  - Never skip the verification workflow—each tool catches different issues.

- **Animation & Micro-Interaction:**
  - Use only compositor-friendly CSS properties (`transform`, `opacity`) for animations.
  - Always respect `prefers-reduced-motion` and test on low-end devices.
  - Use existing animation/interaction systems (e.g., `LazySection`, `PageTransitionWrapper`) and extend via config.

- **Accessibility & Performance:**
  - All color combos must meet WCAG AA contrast (4.5:1).
  - Test for keyboard navigation, screen reader support, and responsive behavior.
  - Never add features that degrade Core Web Vitals or accessibility.

- **Cultural & Client Context:**
  - Maintain Dutch/European professional tone—avoid aggressive marketing patterns.
  - Use meta-descriptive placeholders, not real copy, for all template content.

- **Bug-Fixing & Debugging Patterns:**
  - Always check parent component prop types before extending.
  - Use Tailwind v3+ shorthand classes (e.g., `size-full`, `shrink-0`).
  - For icon usage, always verify the icon exists in the library.
  - For backup/archive files, use `// @ts-nocheck` at the top to avoid TypeScript errors.

- **Critical Red Flags:**
  - "Module has no exported member" → Verify all imports exist.
  - "Type X is not assignable to type Y" → Check parent component prop types.
  - "structuredClone is not a function" → Missing testing dependencies.
  - ESLint import/named errors in tests → Add eslint-disable comment.
  - Tailwind deprecation warnings → Use new shorthand classes.
  - Build failing after icon changes → Verify lucide-react exports.
  - **Buttons inside cards still have hover animations** → Add `animation="none"` prop AND CSS override classes (`hover:scale-100 hover:shadow-none hover:-translate-y-0`). See "Button Hover Effects in Card-Based Designs" in section 18.
  - **Text appears dark/unreadable on dark backgrounds** → Check for conflicting utility classes (e.g., `text-section-lead` + `text-neutral-text-subtle`). Remove utilities with built-in colors and use direct color classes. See "Multi-Layer Text Color Debugging" in section 18.

### What NOT to Do

- Don't add new CSS variables or utility classes that aren't used by components.
- Don't create new systems when existing ones can be extended.
- Don't focus on "trust" or "liveliness" keywords without understanding actual implementation needs.
- Don't skip the full verification workflow before merging or deploying.
- Don't hardcode content or structure in components—always use config/data files.

### How to Avoid Past Mistakes

- Read this doc, the latest design blueprints, and config files before starting any enhancement.
- Validate every change against the current codebase and config.
- Document every new pattern, config, or lesson in this doc for future maintainers.
- When in doubt, ask: "Does this already exist? Can I extend it instead of creating something new?"
- Always prioritize clarity, maintainability, and performance over novelty.

---
